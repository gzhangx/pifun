[{"E:\\me\\pifun\\src\\index.js":"1","E:\\me\\pifun\\src\\App.js":"2","E:\\me\\pifun\\src\\serviceWorker.js":"3","E:\\me\\pifun\\src\\Game.js":"4","E:\\me\\pifun\\src\\core.js":"5","E:\\me\\pifun\\src\\components\\platform\\keyHandler.js":"6","E:\\me\\pifun\\src\\components\\thisworld\\world.js":"7","E:\\me\\pifun\\src\\components\\thisworld\\consts.js":"8","E:\\me\\pifun\\src\\components\\thisworld\\worldConstructor.js":"9","E:\\me\\pifun\\src\\components\\thisworld\\unitui.js":"10","E:\\me\\pifun\\src\\components\\objs\\SimpleCircle.js":"11","E:\\me\\pifun\\src\\components\\objs\\SimpleRect.js":"12","E:\\me\\pifun\\src\\components\\objs\\Cannon.js":"13","E:\\me\\pifun\\src\\components\\platform\\engine.js":"14","E:\\me\\pifun\\src\\components\\thisworld\\ui.js":"15","E:\\me\\pifun\\src\\components\\thisworld\\socket.js":"16"},{"size":503,"mtime":499162500000,"results":"17","hashOfConfig":"18"},{"size":2734,"mtime":1608589254645,"results":"19","hashOfConfig":"18"},{"size":5086,"mtime":499162500000,"results":"20","hashOfConfig":"18"},{"size":526,"mtime":1595082659233,"results":"21","hashOfConfig":"18"},{"size":96,"mtime":1595082679238,"results":"22","hashOfConfig":"18"},{"size":548,"mtime":1593871189860,"results":"23","hashOfConfig":"18"},{"size":7722,"mtime":1598497908219,"results":"24","hashOfConfig":"18"},{"size":2696,"mtime":1599585177283,"results":"25","hashOfConfig":"18"},{"size":22234,"mtime":1599585332126,"results":"26","hashOfConfig":"18"},{"size":6301,"mtime":1596887402126,"results":"27","hashOfConfig":"18"},{"size":382,"mtime":1595101216680,"results":"28","hashOfConfig":"18"},{"size":459,"mtime":1595100995193,"results":"29","hashOfConfig":"18"},{"size":3508,"mtime":1608585925706,"results":"30","hashOfConfig":"18"},{"size":8314,"mtime":1595101205211,"results":"31","hashOfConfig":"18"},{"size":26463,"mtime":1595100964879,"results":"32","hashOfConfig":"18"},{"size":948,"mtime":1608589362382,"results":"33","hashOfConfig":"18"},{"filePath":"34","messages":"35","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},"c2ymlt",{"filePath":"37","messages":"38","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"39","messages":"40","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"41","messages":"42","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"43","messages":"44","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"45","messages":"46","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"47","messages":"48","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"49","usedDeprecatedRules":"36"},{"filePath":"50","messages":"51","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"52","messages":"53","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"54","messages":"55","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"56","usedDeprecatedRules":"36"},{"filePath":"57","messages":"58","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"59","messages":"60","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"61","messages":"62","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"63","messages":"64","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"65","messages":"66","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"67","usedDeprecatedRules":"36"},{"filePath":"68","messages":"69","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"E:\\me\\pifun\\src\\index.js",[],["70","71"],"E:\\me\\pifun\\src\\App.js",[],"E:\\me\\pifun\\src\\serviceWorker.js",[],"E:\\me\\pifun\\src\\Game.js",[],"E:\\me\\pifun\\src\\core.js",[],"E:\\me\\pifun\\src\\components\\platform\\keyHandler.js",[],"E:\\me\\pifun\\src\\components\\thisworld\\world.js",["72","73","74"],"import SimpleCircle from '../objs/SimpleCircle';\nimport SimpleRect from '../objs/SimpleRect';\n\nimport { initWorld, getMouse } from './worldConstructor';\n\nimport { showCannonHolder, createCannon } from '../objs/Cannon';\nimport { postRender } from './unitui';\n\nconst MAX_WALL_WIDTH = 200;\nconst MAX_WALL_HEIGHT = 200;\n//export const allBodies = [];\n\nfunction doWallSketch(core, fromPt, cur) {\n    const { HEIGHT, wallWidth } = core.consts;\n    const {rayQueryWithPoints} = core.createdEngine;\n    const startPt = rayQueryWithPoints({x:fromPt.x, y:fromPt.y},{x: fromPt.x, y: HEIGHT});\n    startPt.forEach(r=>{                        \n        //props.inputs[`setCurCollisionStart`](`${r.x.toFixed(2)}/${r.y.toFixed(2)} `);\n        //p.push();\n        //p.translate(r.x, r.y);\n        //p.text(r.t.toFixed(2), 0,0);        \n        //p.rectMode(p.CENTER);\n        //p.stroke('ff0000');\n        //p.strokeWeight(2);\n        //p.fill('0000ff');                    \n        //p.rect(2,2, 4, 4);\n        //p.pop();\n    });\n\n    const endpt = rayQueryWithPoints({x:cur.x, y:cur.y},{x: cur.x, y: HEIGHT});\n    const start = startPt[0];\n    return {\n        ok: Math.abs(cur.x - fromPt.x) > wallWidth * 2 && start,\n        start,\n        end: endpt[0],\n    }\n}\n\nexport default  {\n    //WIDTH,\n    //HEIGHT,\n    setup: (canvas, props, core) => {\n        const { WIDTH, HEIGHT } = core.consts;\n        initWorld(core, {\n            canvas, run, props,\n            renderOpts: {\n                showAxes: true,\n                hasBounds: true,\n                width: WIDTH,\n                height: HEIGHT,\n                postRender,\n                core,\n            },\n        });\n        createWorld(core);\n        return core;\n    },    \n};\n\nconst screenOff = {\n    x: 0,\n    y: 0,\n}\nfunction run(core, props) {\n    const {\n        WALLHEALTH,\n    } = core.consts;\n    //const { props } = opt;\n    const { curBuildType } = core.inputs;\n    const { setCurDebugText } = props.inputs;\n    const isWallMode = curBuildType === 'wall';\n    const isFireMode = curBuildType === 'fire';\n    const isCannonMode = curBuildType === 'cannon';\n    const isConnection = curBuildType === 'connection';\n    const isSelect = curBuildType === 'select';\n    const { mouseConstraint } = core;\n    \n    const mouse = core.states.mouse;\n    mouseConstraint.disabled = !isSelect && mouse.pressLocation;\n    const { engine, rayQueryWithPoints, Vector, Composite } = core.createdEngine;\n    const { getDragCellPoints, makeCell, worldOperations,\n        doSelect,\n        showSelect,\n        doTranslate,\n        doFireBall,\n        checkWallPoints,\n    } = core.worldCon;\n    //removeBadBodies();\n    //processCollisions(core);\n    worldOperations();\n    const allBodies = Composite.allBodies(engine.world);\n\n\n    const c = core.render.context;\n    const side = core.inputs.curSide;\n    const key = core.inputs.loopKey;\n    \n    setCurDebugText(\"key=\" + core.inputs.lastKey + ` bodyCnt=${allBodies.length} cnsts=${Composite.allConstraints(engine.world).length}`);\n    \n\n    \n    if (key === 'c' || key === 'v') {\n        if (key === 'c') screenOff.y += 10;\n        if (key === 'v') screenOff.y -= 10;\n        core.inputs.loopKey = '';\n        doTranslate(screenOff);\n    }\n    //if (core.inputs.curBuildType === 'wall') \n\n    if (isSelect) {\n        doSelect();\n    }\n    core.uiDspInfo.selectInfo = showSelect({ isSelect, key, side });\n    if (isCannonMode && mouse.state === 'dragged') {\n        core.uiDspInfo.cannonHolder = showCannonHolder({ c, core, allBodies, setCurDebugText }, {\n            x: mouse.cur.x,\n            y: mouse.cur.y,\n        })\n    }\n    if (!mouse.pressLocation) return;\n    if (!mouse.cur) return;\n\n    if (mouse.state === 'dragged') {\n        if (isFireMode || isConnection) {\n            core.uiDspInfo.fireDirInfo = {\n                from: getMouse(mouse.pressLocation),\n                to: getMouse(mouse.cur),\n            };\n        }\n\n        if (isWallMode) {\n            rayQueryWithPoints({ x: mouse.pressLocation.x, y: mouse.pressLocation.y }, { x: mouse.cur.x, y: mouse.cur.y });\n            //props.inputs[`setCurCollisionStart`](`${dists} `);                    \n            const endPoints = doWallSketch(core, mouse.pressLocation, mouse.cur);\n            if (!endPoints.ok || !endPoints.end) return;\n\n            const wallPts = getDragCellPoints(mouse.pressLocation, mouse.cur, endPoints);\n            core.states.lastGoodWallPts = null;\n            core.uiDspInfo.wallPts = wallPts;\n            const totalWallLen = checkWallPoints(wallPts);\n            if (totalWallLen !== null) {\n                setCurDebugText(`walllen=${totalWallLen}`);\n            }\n            //drawCellPointsCnv(wallPts);\n        }\n\n    } else if (mouse.state === 'released') {\n        mouse.state = '';\n        const mouseFrom = getMouse(mouse.pressLocation);\n        const mouseCur = getMouse(mouse.cur);\n        core.states.mouse.pressLocation = null;\n            \n        if (isCannonMode) {\n            createCannon({ core, allBodies, side }, mouseCur);\n        }\n        if (isConnection) {\n            const bodyA = core.createdEngine.getBodiesUnderPos(mouse.cur);\n            if (!bodyA) return;\n            const pointA = { x: mouse.cur.x - bodyA.position.x, y: mouse.cur.y - bodyA.position.y };\n            const pointB = Vector.sub(mouseFrom, mouseConstraint.body.position);\n            core.worldCon.addCst({ bodyB: mouseConstraint.body, bodyA, pointB, pointA });\n        }\n        if (isFireMode) {\n            if (!mouseFrom) return;\n            return doFireBall(mouseFrom, mouseCur, side);\n        }\n\n        if (isWallMode) {\n            const endPoints = doWallSketch(core, mouseFrom, mouseCur);\n            if (!endPoints.ok || !endPoints.end) return;\n            const wallPts = getDragCellPoints(mouseFrom, mouseCur, endPoints);\n            if (wallPts && wallPts.connects && wallPts.connects.length) {\n                core.uiDspInfo.wallPts = wallPts;\n                //drawCellPointsCnv(wallPts);\n                const allWalls=makeCell(wallPts.connects,endPoints,core.worldCats.getCat(side).structure.getCollisionFilter(),\n                    {\n                        side,\n                        player: side + 1,\n                });\n                allWalls.forEach(w => w.health = WALLHEALTH);\n                return allWalls;\n            }\n        }\n    }\n    \n}\n\n\nfunction createWorld(core) {\n\n    //(categoryA & maskB) !== 0 and (categoryB & maskA) !== 0    \n    //const { addToWorld, Bodies, Body } = core.createdEngine;\n    const { worldCats, createdEngine, consts } = core;\n    const { WIDTH, HEIGHT} = consts;\n    \n    new SimpleCircle({\n        x: 210,\n        y: 100,\n        r: 30,\n        ggOpts: {\n            isImmortal: true,\n        },\n        opts: { restitution: 0.5, collisionFilter: worldCats.ground.structure.getCollisionFilter()},\n    }, createdEngine);\n\n    new SimpleRect({\n        x: 310,\n        y: 100,\n        w: 30,\n        h: 60,\n        ggOpts: {\n            isImmortal: true,\n            h: 60,\n        },\n        opts: { restitution: 0.5, collisionFilter: worldCats.ground.structure.getCollisionFilter()},\n    }, createdEngine);\n    \n    const GroundHeight = 200;\n    new SimpleRect({\n        x: WIDTH/2,\n        y: HEIGHT + GroundHeight/2- 10,\n        w: WIDTH,\n        h: GroundHeight,\n        ggOpts: {\n            isImmortal: true,\n            h: GroundHeight,\n            player: 'groundPerm'\n        },\n        opts: { isStatic: true, label: 'Ground', collisionFilter: worldCats.ground.structure.getCollisionFilter()},\n    }, createdEngine);\n\n\n    //addToWorld([\n    //  // walls      \n    //  Bodies.rectangle(WIDTH/2, HEIGHT, WIDTH, 60, { isStatic: true })\n    //])\n}","E:\\me\\pifun\\src\\components\\thisworld\\consts.js",[],"E:\\me\\pifun\\src\\components\\thisworld\\worldConstructor.js",[],"E:\\me\\pifun\\src\\components\\thisworld\\unitui.js",["75"],"import { getDispAng } from '../platform/engine';\r\nconst drawCellPointsCnv = (p, dspInfo) => {\r\n    const { connects , points} = dspInfo.wallPts || {};\r\n    dspInfo.wallPts = { connects: [], points:[] };\r\n    if (!connects) return;\r\n    connects.reduce((acc, c) => {\r\n        const showRect = (rr, stroke = '#ff0000', fill = '#0000ff') => {\r\n            p.save();\r\n            p.translate(rr.x, rr.y);\r\n            p.rotate(getDispAng(rr.angle || 0));\r\n            //p.stroke(stroke);\r\n            //p.strokeWeight(2);\r\n            //p.fill(fill);\r\n            p.fillStyle = fill;\r\n            p.fillRect(-(rr.w / 2), -(rr.h / 2), rr.w, rr.h);\r\n            p.restore();\r\n        };\r\n\r\n        const chkshow = a => {\r\n            if (acc[a.id]) return;\r\n            acc[a.id] = a;\r\n            showRect(a);\r\n        }\r\n        const { a, b } = c;\r\n        chkshow(a);\r\n        chkshow(b);\r\n\r\n        p.save();\r\n        //p.stroke('#00ff00');\r\n        //p.strokeWeight(2);        \r\n        //p.line(xa, ya, xb, yb);\r\n        showRect(Object.assign({}, a, { w: 20, h: 20 }), '#223344', '#0000ff');\r\n        //showRect({ x: a.x + pointA.x, y: a.y + pointA.y, w: 10, h: 10 }, '#223344', '#00ff00');\r\n        //showRect({ x: b.x + pointB.x + 10, y: b.y + pointB.y, w: 10, h: 10 }, '#223344', '#ff0000');\r\n        //setCurDebugText(`debugremove ===> ${dbgfmtPt(mouse.cur)} ax=${dbgfmtPt(a)} da=${dbgfmtPt(pointA)} bx is ${dbgfmtPt(b)} db=da=${dbgfmtPt(pointB)}`);\r\n        //p.line(xa, ya, xb, yb);\r\n\r\n        p.restore();\r\n        return acc;\r\n    }, {});\r\n}\r\n\r\n\r\n\r\nexport function showCannonHolder(c, dspInfo) {\r\n    if (!dspInfo.cannonHolder) return;\r\n    const { x, y, w, h, cannonInfo: rrr } = dspInfo.cannonHolder;\r\n    if (!rrr) return;\r\n    dspInfo.cannonHolder = null;\r\n    const { p1, p2 } = rrr.queryInfo.edge;\r\n    const { newC, fromEnd1, fromEnd2, goodPts } = rrr;\r\n    const projPt = rrr.projPt; //getProjectionPoint(p1, p2, { x, y });\r\n    if (projPt) {\r\n        if (projPt.inRange) {            \r\n            c.save();\r\n            c.strokeStyle = '#0000ff';\r\n            c.strokeWeight = 8;\r\n            c.beginPath();\r\n            c.moveTo(x, y);\r\n            c.lineTo(p1.x, p1.y);\r\n            c.moveTo(x, y);\r\n            c.lineTo(p2.x, p2.y);\r\n            c.stroke();\r\n            c.strokeStyle = '#0000ff';\r\n            c.strokeWeight = 4;\r\n            //c.fill(127);\r\n            c.beginPath();\r\n            c.moveTo(x, y);\r\n            c.lineTo(projPt.x, projPt.y);\r\n            c.stroke();\r\n            c.restore();\r\n\r\n            const angle = newC.angle;\r\n            c.beginPath();\r\n            c.strokeStyle = '#bbb';\r\n            c.strokeWeight = 4;\r\n            c.beginPath();\r\n            c.arc(fromEnd1.x, fromEnd1.y, 10, 0, 2 * Math.PI);\r\n            c.stroke();\r\n            c.strokeStyle = '#222';\r\n            c.beginPath();\r\n            c.arc(fromEnd2.x, fromEnd2.y, 10, 0, 2 * Math.PI);\r\n            c.stroke();\r\n            c.save();\r\n            c.translate(newC.x, newC.y);\r\n            c.rotate(angle || 0);\r\n            c.strokeStyle = '#bbb';\r\n            c.strokeWeight = 4;\r\n            //c.fill(127);\r\n            c.beginPath();\r\n            c.strokeStyle = '#222222';\r\n            c.fillStyle = '#222222';\r\n            c.fillText(((angle / Math.PI) * 180).toFixed(0), 0, 0);\r\n            c.rect(-w / 2, -h / 2, w, h);\r\n            c.stroke();\r\n\r\n            c.restore();\r\n            c.save();\r\n            c.beginPath();\r\n            c.strokeStyle = '#bbb';\r\n            c.strokeWeight = 4;\r\n            //c.translate(fromEnd1.x, fromEnd1.y);\r\n            c.beginPath();\r\n            c.rect(fromEnd1.x - 5, fromEnd1.y - 5, 10, 10);\r\n            c.stroke();\r\n            c.beginPath();\r\n            c.rect(fromEnd2.x - 5, fromEnd2.y - 5, 10, 10);\r\n            c.stroke();\r\n            const colors = ['#ff0000', '#00ff00', '#0000ff', '#ffaaff']\r\n            goodPts.map((pt, i) => {\r\n                const size = 20 - i * 3;\r\n                c.beginPath();\r\n                c.strokeStyle = colors[i];\r\n                c.rect(pt.x - (size / 2), pt.y - (size / 2), size, size);\r\n                c.stroke();\r\n                return null;\r\n            })\r\n            c.restore();\r\n        }\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\nfunction showSelect(c, dspInfo) {\r\n    const selectInfo = dspInfo.selectInfo;\r\n    if (!selectInfo) return;        \r\n    dspInfo.selectInfo = null;\r\n    c.beginPath();\r\n    c.strokeStyle = '#00ff00';\r\n    c.strokeWeight = 10;\r\n    c.fillStyle = '#00ff00';\r\n    const bodyPos = selectInfo.bodyPos;\r\n    if (bodyPos) {\r\n        c.fillRect(bodyPos.x - 5, bodyPos.y - 5, 10, 10);\r\n    } else if (selectInfo.constraint){\r\n        const { start, end } = selectInfo.constraint;\r\n\r\n        c.moveTo(start.x, start.y);\r\n        c.lineTo(end.x + 5, end.y + 5);\r\n        c.lineWidth = 10;\r\n    }\r\n    c.stroke();\r\n\r\n    if (selectInfo.cannonCone) {\r\n        const {\r\n            bpx,\r\n            bpy,\r\n            to1,\r\n            len,\r\n            degl2, degl1,\r\n        } = selectInfo.cannonCone;\r\n                \r\n        //setCurDebugText(`dirxy=${dirx.toFixed(0)} ${diry.toFixed(0)}`);\r\n        if (selectInfo.cannonDir) {\r\n                \r\n            const {\r\n                to,\r\n            } = selectInfo.cannonDir;\r\n            c.beginPath();\r\n            c.lineWidth = 3;\r\n            c.strokeStyle = \"000\";\r\n            c.moveTo(bpx, bpy);\r\n            c.lineTo(to.x, to.y);\r\n            c.stroke();\r\n        }\r\n        c.beginPath();\r\n        c.fillStyle = \"rgba(255, 0, 128, 0.2)\";\r\n        c.moveTo(bpx, bpy);\r\n        c.lineTo(to1.x, to1.y);\r\n        c.arc(bpx, bpy, len, degl2, degl1)\r\n        c.lineTo(bpx, bpy);\r\n        c.fill();\r\n        c.stroke();        \r\n    }\r\n}\r\n\r\nfunction showFireLine(c, dspInfo) {\r\n    if (dspInfo.fireDirInfo) {\r\n        const { from, to } = dspInfo.fireDirInfo;\r\n        dspInfo.fireDirInfo = null;        \r\n        c.beginPath();\r\n        c.lineWidth = 5;\r\n        c.strokeStyle = 'red';\r\n        c.moveTo(from.x, from.y);\r\n        c.lineTo(to.x, to.y);\r\n        c.stroke();\r\n    }\r\n}\r\n\r\nexport function postRender(c, opts) {\r\n    const dspInfo = opts.core.uiDspInfo;\r\n    showFireLine(c, dspInfo);\r\n    drawCellPointsCnv(c, dspInfo);\r\n    showCannonHolder(c, dspInfo);\r\n    showSelect(c, dspInfo);    \r\n}\r\n\r\n","E:\\me\\pifun\\src\\components\\objs\\SimpleCircle.js",[],"E:\\me\\pifun\\src\\components\\objs\\SimpleRect.js",[],"E:\\me\\pifun\\src\\components\\objs\\Cannon.js",[],"E:\\me\\pifun\\src\\components\\platform\\engine.js",[],"E:\\me\\pifun\\src\\components\\thisworld\\ui.js",["76"],"// Customized from https://raw.githubusercontent.com/liabru/matter-js/master/src/render/Render.js\r\n// Better than original p5js impl\r\n// must set opt.core, opt.canvas and opt.mouse\r\n\r\n//import { Vector, Body, Bounds, Mouse } from \"matter-js\";\r\nlet _requestAnimationFrame,\r\n    // eslint-disable-next-line\r\n    _cancelAnimationFrame;\r\n\r\nexport const createRender = (opt) => {\r\n    const { createdEngine } = opt.core;\r\n    const { Composite, engine, Bounds, Vector, Common} = createdEngine;\r\n    const world = engine.world;\r\n    const context = opt.canvas.getContext('2d');\r\n    const canvas = opt.canvas;\r\n    const Mouse = opt.Mouse;\r\n    const options = opt.options || {};\r\n    canvas.width = options.width || canvas.width;\r\n    canvas.height = options.height || canvas.height;\r\n    options.width = canvas.width;\r\n    options.height = canvas.height;\r\n    const render =\r\n    {\r\n        mouse: opt.mouse,\r\n        engine,\r\n        canvas,\r\n        context,\r\n        options,\r\n        textures: {},\r\n    };\r\n\r\n    render.bounds = opt.bounds || {\r\n        min: {\r\n            x: 0,\r\n            y: 0\r\n        },\r\n        max: {\r\n            x: canvas.width,\r\n            y: canvas.height\r\n        }\r\n    };\r\n\r\n    function _getPixelRatio(canvas) {\r\n        var context = canvas.getContext('2d'),\r\n            devicePixelRatio = window.devicePixelRatio || 1,\r\n            backingStorePixelRatio = context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio\r\n                || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio\r\n                || context.backingStorePixelRatio || 1;\r\n\r\n        return devicePixelRatio / backingStorePixelRatio;\r\n    };\r\n    function setPixelRatio(pixelRatio) {        \r\n        if (pixelRatio === 'auto') {\r\n            pixelRatio = _getPixelRatio(canvas);\r\n        }\r\n\r\n        options.pixelRatio = pixelRatio;\r\n        canvas.setAttribute('data-pixel-ratio', pixelRatio);\r\n        canvas.width = options.width * pixelRatio;\r\n        canvas.height = options.height * pixelRatio;\r\n        canvas.style.width = options.width + 'px';\r\n        canvas.style.height = options.height + 'px';\r\n    };\r\n\r\n    if (render.options.pixelRatio !== 1) {\r\n        setPixelRatio(options.pixelRatio || 1);\r\n    }\r\n\r\n    if (typeof window !== 'undefined') {\r\n        _requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame\r\n            || window.mozRequestAnimationFrame || window.msRequestAnimationFrame\r\n            || function (callback) { window.setTimeout(function () { callback(Common.now()); }, 1000 / 60); };\r\n\r\n        _cancelAnimationFrame = window.cancelAnimationFrame || window.mozCancelAnimationFrame\r\n            || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame;\r\n    }\r\n    function _applyBackground(render, background) {\r\n        let cssBackground = background;\r\n        if (/(jpg|gif|png)$/.test(background))\r\n            cssBackground = 'url(' + background + ')';\r\n\r\n        render.canvas.style.background = cssBackground;\r\n        render.canvas.style.backgroundSize = \"contain\";\r\n        render.currentBackground = background;\r\n    }\r\n\r\n    /**\r\n    * Applies viewport transforms based on `render.bounds` to a render context.\r\n    * @method startViewTransform\r\n    * @param {render} render\r\n    */\r\n    render.startViewTransform = function () {\r\n        var boundsWidth = render.bounds.max.x - render.bounds.min.x,\r\n            boundsHeight = render.bounds.max.y - render.bounds.min.y,\r\n            boundsScaleX = boundsWidth / render.options.width,\r\n            boundsScaleY = boundsHeight / render.options.height;\r\n\r\n        render.context.setTransform(\r\n            render.options.pixelRatio / boundsScaleX, 0, 0,\r\n            render.options.pixelRatio / boundsScaleY, 0, 0\r\n        );\r\n\r\n        render.context.translate(-render.bounds.min.x, -render.bounds.min.y);\r\n    };\r\n\r\n    /**\r\n     * Resets all transforms on the render context.\r\n     * @method endViewTransform\r\n     * @param {render} render\r\n     */\r\n    render.endViewTransform = function () {\r\n        render.context.setTransform(render.options.pixelRatio, 0, 0, render.options.pixelRatio, 0, 0);\r\n    };\r\n    \r\n    render.run = function () {\r\n        (function loop(time) {\r\n            render.frameRequestId = _requestAnimationFrame(loop);            \r\n            render.draw();\r\n            if (opt.run) opt.run();\r\n        })();\r\n    };\r\n    render.draw = () => {        \r\n        const options = render.options,\r\n            allBodies = Composite.allBodies(world),\r\n            allConstraints = Composite.allConstraints(world),\r\n            background = options.background;\r\n        let bodies = [],\r\n            constraints = [],\r\n            i;\r\n\r\n        // apply background if it has changed\r\n        if (render.currentBackground !== background)\r\n            _applyBackground(render, background);\r\n\r\n        // clear the canvas with a transparent fill, to allow the canvas background to show\r\n        context.globalCompositeOperation = 'source-in';\r\n        context.fillStyle = \"transparent\";\r\n        context.fillRect(0, 0, canvas.width, canvas.height);\r\n        context.globalCompositeOperation = 'source-over';\r\n\r\n        // handle bounds\r\n        if (options.hasBounds) {\r\n            // filter out bodies that are not in view\r\n            for (i = 0; i < allBodies.length; i++) {\r\n                var body = allBodies[i];\r\n                if (Bounds.overlaps(body.bounds, render.bounds))\r\n                    bodies.push(body);\r\n            }\r\n\r\n            // filter out constraints that are not in view\r\n            for (i = 0; i < allConstraints.length; i++) {\r\n                var constraint = allConstraints[i],\r\n                    bodyA = constraint.bodyA,\r\n                    bodyB = constraint.bodyB,\r\n                    pointAWorld = constraint.pointA,\r\n                    pointBWorld = constraint.pointB;\r\n\r\n                if (bodyA) pointAWorld = Vector.add(bodyA.position, constraint.pointA);\r\n                if (bodyB) pointBWorld = Vector.add(bodyB.position, constraint.pointB);\r\n\r\n                if (!pointAWorld || !pointBWorld)\r\n                    continue;\r\n\r\n                if (Bounds.contains(render.bounds, pointAWorld) || Bounds.contains(render.bounds, pointBWorld))\r\n                    constraints.push(constraint);\r\n            }\r\n\r\n            // transform the view\r\n            render.startViewTransform(render);\r\n\r\n            // update mouse\r\n            if (render.mouse) {\r\n                Mouse.setScale(render.mouse, {\r\n                    x: (render.bounds.max.x - render.bounds.min.x) / render.options.width,\r\n                    y: (render.bounds.max.y - render.bounds.min.y) / render.options.height\r\n                });\r\n\r\n                Mouse.setOffset(render.mouse, render.bounds.min);\r\n            }\r\n        } else {\r\n            constraints = allConstraints;\r\n            bodies = allBodies;\r\n\r\n            if (render.options.pixelRatio !== 1) {\r\n                render.context.setTransform(render.options.pixelRatio, 0, 0, render.options.pixelRatio, 0, 0);\r\n            }\r\n        }\r\n\r\n        // fully featured rendering of bodies\r\n        render.bodies(bodies);\r\n\r\n        if (options.showBounds)\r\n            render.bodyBounds(bodies);\r\n\r\n        if (options.showAxes || options.showAngleIndicator)\r\n            render.bodyAxes(bodies);\r\n\r\n        if (options.showPositions)\r\n            render.bodyPositions(bodies);\r\n\r\n        if (options.showVelocity)\r\n            render.bodyVelocity(bodies);\r\n\r\n        if (options.showIds)\r\n            render.bodyIds(bodies);\r\n\r\n        if (options.showSeparations)\r\n            render.separations(engine.pairs.list);\r\n\r\n        if (options.showCollisions)\r\n            render.collisions(engine.pairs.list);\r\n\r\n        if (options.showMousePosition)\r\n            render.mousePosition(render.mouse);\r\n\r\n        render.constraints(constraints, context);\r\n\r\n        options.postRender(context, options);\r\n        if (options.hasBounds) {\r\n            // revert view transforms\r\n            render.endViewTransform(render);\r\n        }\r\n\r\n    }\r\n\r\n\r\n    /**\r\n     * Description\r\n     * @private\r\n     * @method bodies\r\n     * @param {body[]} bodies\r\n     */\r\n    render.bodies = function (bodies) {\r\n        const c = context,\r\n            options = render.options,\r\n            showInternalEdges = options.showInternalEdges || !options.wireframes;\r\n        let body,\r\n            part,\r\n            i,\r\n            k;\r\n\r\n        for (i = 0; i < bodies.length; i++) {\r\n            body = bodies[i];\r\n\r\n            if (!body.render.visible)\r\n                continue;\r\n\r\n            // handle compound parts\r\n            for (k = body.parts.length > 1 ? 1 : 0; k < body.parts.length; k++) {\r\n                part = body.parts[k];\r\n\r\n                if (!part.render.visible)\r\n                    continue;\r\n\r\n                if (options.showSleeping && body.isSleeping) {\r\n                    c.globalAlpha = 0.5 * part.render.opacity;\r\n                } else if (part.render.opacity !== 1) {\r\n                    c.globalAlpha = part.render.opacity;\r\n                }\r\n\r\n                if (part.render.sprite && part.render.sprite.texture && !options.wireframes) {\r\n                    // part sprite\r\n                    var sprite = part.render.sprite,\r\n                        texture = _getTexture(render, sprite.texture);\r\n\r\n                    c.translate(part.position.x, part.position.y);\r\n                    c.rotate(part.angle);\r\n\r\n                    c.drawImage(\r\n                        texture,\r\n                        texture.width * -sprite.xOffset * sprite.xScale,\r\n                        texture.height * -sprite.yOffset * sprite.yScale,\r\n                        texture.width * sprite.xScale,\r\n                        texture.height * sprite.yScale\r\n                    );\r\n\r\n                    // revert translation, hopefully faster than save / restore\r\n                    c.rotate(-part.angle);\r\n                    c.translate(-part.position.x, -part.position.y);\r\n                } else {\r\n                    // part polygon\r\n                    if (part.circleRadius) {\r\n                        c.beginPath();\r\n                        c.arc(part.position.x, part.position.y, part.circleRadius, 0, 2 * Math.PI);\r\n                    } else {\r\n                        c.beginPath();\r\n                        c.moveTo(part.vertices[0].x, part.vertices[0].y);\r\n\r\n                        for (var j = 1; j < part.vertices.length; j++) {\r\n                            if (!part.vertices[j - 1].isInternal || showInternalEdges) {\r\n                                c.lineTo(part.vertices[j].x, part.vertices[j].y);\r\n                            } else {\r\n                                c.moveTo(part.vertices[j].x, part.vertices[j].y);\r\n                            }\r\n\r\n                            if (part.vertices[j].isInternal && !showInternalEdges) {\r\n                                c.moveTo(part.vertices[(j + 1) % part.vertices.length].x, part.vertices[(j + 1) % part.vertices.length].y);\r\n                            }\r\n                        }\r\n\r\n                        c.lineTo(part.vertices[0].x, part.vertices[0].y);\r\n                        c.closePath();\r\n                    }\r\n\r\n                    if (!options.wireframes) {\r\n                        c.fillStyle = part.render.fillStyle;\r\n\r\n                        if (part.render.lineWidth) {\r\n                            c.lineWidth = part.render.lineWidth;\r\n                            c.strokeStyle = part.render.strokeStyle;\r\n                            c.stroke();\r\n                        }\r\n\r\n                        c.fill();\r\n                    } else {\r\n                        c.lineWidth = 1;\r\n                        c.strokeStyle = '#bbb';\r\n                        c.stroke();\r\n                    }\r\n                }\r\n\r\n                c.globalAlpha = 1;\r\n            }\r\n\r\n            const ggInfo = body.ggInfo;\r\n            if (ggInfo) {\r\n                if (ggInfo.label === 'Cannon') {\r\n                    const part = body.parts[0];\r\n                    const p1 = part.vertices[ggInfo.dir[0]];\r\n                    const p2 = part.vertices[ggInfo.dir[1]];\r\n                    const v = Vector.sub(p2, p1);\r\n                    const vn = Vector.normalise(v);\r\n                    vn.x *= 100;\r\n                    vn.y *= 100;\r\n                    c.beginPath();\r\n                    c.moveTo(body.position.x, body.position.y);\r\n                    const to = Vector.add(vn, body.position);\r\n                    c.lineTo(to.x, to.y);\r\n                    c.lineWidth = 3;\r\n                    c.strokeStyle = '#000';\r\n                    c.stroke();\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n\r\n    /**\r\n     * Description\r\n     * @private\r\n     * @method constraints\r\n     * @param {constraint[]} constraints\r\n     */\r\n    render.constraints = function (constraints) {\r\n        const c = context;\r\n\r\n        for (let i = 0; i < constraints.length; i++) {\r\n            const constraint = constraints[i];\r\n\r\n            if (!constraint.render.visible || !constraint.pointA || !constraint.pointB)\r\n                continue;\r\n\r\n            const bodyA = constraint.bodyA,\r\n                bodyB = constraint.bodyB;\r\n            \r\n            let start, end;\r\n\r\n            if (bodyA) {\r\n                start = Vector.add(bodyA.position, constraint.pointA);\r\n            } else {\r\n                start = constraint.pointA;\r\n            }\r\n\r\n            if (constraint.render.type === 'pin') {\r\n                c.beginPath();\r\n                c.arc(start.x, start.y, 3, 0, 2 * Math.PI);\r\n                c.closePath();\r\n            } else {\r\n                if (bodyB) {\r\n                    end = Vector.add(bodyB.position, constraint.pointB);\r\n                } else {\r\n                    end = constraint.pointB;\r\n                }\r\n\r\n                c.beginPath();\r\n                c.moveTo(start.x, start.y);\r\n\r\n                if (constraint.render.type === 'spring') {\r\n                    var delta = Vector.sub(end, start),\r\n                        normal = Vector.perp(Vector.normalise(delta)),\r\n                        coils = Math.ceil(Common.clamp(constraint.length / 5, 12, 20)),\r\n                        offset;\r\n\r\n                    for (var j = 1; j < coils; j += 1) {\r\n                        offset = j % 2 === 0 ? 1 : -1;\r\n\r\n                        c.lineTo(\r\n                            start.x + delta.x * (j / coils) + normal.x * offset * 4,\r\n                            start.y + delta.y * (j / coils) + normal.y * offset * 4\r\n                        );\r\n                    }\r\n                }\r\n\r\n                c.lineTo(end.x, end.y);\r\n            }\r\n\r\n            if (constraint.render.lineWidth) {\r\n                c.lineWidth = constraint.render.lineWidth;\r\n                c.strokeStyle = constraint.render.strokeStyle;\r\n                c.stroke();\r\n            }\r\n\r\n            if (constraint.render.anchors) {\r\n                c.fillStyle = constraint.render.strokeStyle;\r\n                c.beginPath();\r\n                c.arc(start.x, start.y, 3, 0, 2 * Math.PI);\r\n                c.arc(end.x, end.y, 3, 0, 2 * Math.PI);\r\n                c.closePath();\r\n                c.fill();\r\n            }\r\n        }\r\n    };\r\n\r\n    render.line = (p1, p2) => {\r\n        context.beginPath();\r\n        context.moveTo(p1.x, p1.y);\r\n        context.lineTo(p2.x, p2.y);\r\n        context.stroke();\r\n    }\r\n\r\n    /**\r\n   * Draws body angle indicators and axes\r\n   * @private\r\n   * @method bodyAxes\r\n   * @param {render} render\r\n   * @param {body[]} bodies\r\n   * @param {RenderingContext} context\r\n   */\r\n    render.bodyAxes = function (bodies) {\r\n        var c = context,\r\n            options = render.options,\r\n            part,\r\n            i,\r\n            j,\r\n            k;\r\n\r\n        c.beginPath();\r\n\r\n        for (i = 0; i < bodies.length; i++) {\r\n            var body = bodies[i],\r\n                parts = body.parts;\r\n\r\n            if (!body.render.visible)\r\n                continue;\r\n\r\n            if (options.showAxes) {\r\n                // render all axes\r\n                const axeslen = 5; //default 20;\r\n                for (j = parts.length > 1 ? 1 : 0; j < parts.length; j++) {\r\n                    part = parts[j];\r\n                    for (k = 0; k < part.axes.length; k++) {\r\n                        var axis = part.axes[k];\r\n                        c.beginPath();\r\n                        if (k === 0) {\r\n                            c.strokeStyle = '#ff0000';\r\n                            c.lineWidth = 2;\r\n                        } else {\r\n                            c.strokeStyle = 'indianred';\r\n                            c.lineWidth = 1;\r\n                        }\r\n                        c.moveTo(part.position.x, part.position.y);\r\n                        c.lineTo(part.position.x + axis.x * axeslen, part.position.y + axis.y * axeslen);\r\n                        c.stroke();\r\n                    }\r\n                }\r\n                c.beginPath();\r\n                c.fillStyle = '#222222';\r\n                //show angle\r\n                //c.fillText(((body.angle / Math.PI) * 180).toFixed(0), body.position.x, body.position.y);\r\n                if (body.ggInfo) {\r\n                    if (body.ggInfo.health) {\r\n                        c.fillText((body.ggInfo.health).toFixed(0), body.position.x, body.position.y);\r\n                    }\r\n                }\r\n                c.stroke();\r\n                const colors = ['#ff0000', '#000000', '#ff0000', '#000000'];\r\n                let p1 = null, p2 = null;\r\n                for (let i = 0; i < body.vertices.length; i++) {\r\n                    if (i > 2) break;\r\n                    c.beginPath();\r\n                    p2 = body.vertices[i];\r\n                    if (!p1) {\r\n                        p1 = p2;\r\n                        continue;\r\n                    }\r\n                    \r\n                    c.moveTo(p1.x, p1.y);\r\n                    c.lineTo(p2.x, p2.y);\r\n                    c.strokeStyle = colors[i];\r\n                    c.lineWidth = 2;\r\n                    c.stroke();\r\n                    p1 = p2;\r\n                }\r\n            } else {\r\n                for (j = parts.length > 1 ? 1 : 0; j < parts.length; j++) {\r\n                    part = parts[j];\r\n                    for (k = 0; k < part.axes.length; k++) {\r\n                        // render a single axis indicator\r\n                        c.moveTo(part.position.x, part.position.y);\r\n                        c.lineTo((part.vertices[0].x + part.vertices[part.vertices.length - 1].x) / 2,\r\n                            (part.vertices[0].y + part.vertices[part.vertices.length - 1].y) / 2);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (options.wireframes) {\r\n            c.strokeStyle = 'indianred';\r\n            c.lineWidth = 1;\r\n        } else {\r\n            c.strokeStyle = 'rgba(255, 255, 255, 0.4)';\r\n            c.globalCompositeOperation = 'overlay';\r\n            c.lineWidth = 2;\r\n        }\r\n\r\n        c.stroke();\r\n        c.globalCompositeOperation = 'source-over';\r\n    };\r\n\r\n    /**\r\n     * Draws body positions\r\n     * @private\r\n     * @method bodyPositions\r\n     * @param {render} render\r\n     * @param {body[]} bodies\r\n     * @param {RenderingContext} context\r\n     */\r\n    render.bodyPositions = function (bodies) {\r\n        var c = context,\r\n            options = render.options,\r\n            body,\r\n            part,\r\n            i,\r\n            k;\r\n\r\n        c.beginPath();\r\n\r\n        // render current positions\r\n        for (i = 0; i < bodies.length; i++) {\r\n            body = bodies[i];\r\n\r\n            if (!body.render.visible)\r\n                continue;\r\n\r\n            // handle compound parts\r\n            for (k = 0; k < body.parts.length; k++) {\r\n                part = body.parts[k];\r\n                c.arc(part.position.x, part.position.y, 3, 0, 2 * Math.PI, false);\r\n                c.closePath();\r\n            }\r\n        }\r\n\r\n        if (options.wireframes) {\r\n            c.fillStyle = 'indianred';\r\n        } else {\r\n            c.fillStyle = 'rgba(0,0,0,0.5)';\r\n        }\r\n        c.fill();\r\n\r\n        c.beginPath();\r\n\r\n        // render previous positions\r\n        for (i = 0; i < bodies.length; i++) {\r\n            body = bodies[i];\r\n            if (body.render.visible) {\r\n                c.arc(body.positionPrev.x, body.positionPrev.y, 2, 0, 2 * Math.PI, false);\r\n                c.closePath();\r\n            }\r\n        }\r\n\r\n        c.fillStyle = 'rgba(255,165,0,0.8)';\r\n        c.fill();\r\n    };\r\n\r\n    /**\r\n     * Draws body velocity\r\n     * @private\r\n     * @method bodyVelocity\r\n     * @param {render} render\r\n     * @param {body[]} bodies\r\n     * @param {RenderingContext} context\r\n     */\r\n    render.bodyVelocity = function (bodies) {\r\n        var c = context;\r\n\r\n        c.beginPath();\r\n\r\n        for (var i = 0; i < bodies.length; i++) {\r\n            var body = bodies[i];\r\n\r\n            if (!body.render.visible)\r\n                continue;\r\n\r\n            c.moveTo(body.position.x, body.position.y);\r\n            c.lineTo(body.position.x + (body.position.x - body.positionPrev.x) * 2, body.position.y + (body.position.y - body.positionPrev.y) * 2);\r\n        }\r\n\r\n        c.lineWidth = 3;\r\n        c.strokeStyle = 'cornflowerblue';\r\n        c.stroke();\r\n    };\r\n\r\n    /**\r\n     * Draws body ids\r\n     * @private\r\n     * @method bodyIds\r\n     * @param {render} render\r\n     * @param {body[]} bodies\r\n     * @param {RenderingContext} context\r\n     */\r\n    render.bodyIds = function (bodies) {\r\n        var c = context,\r\n            i,\r\n            j;\r\n\r\n        for (i = 0; i < bodies.length; i++) {\r\n            if (!bodies[i].render.visible)\r\n                continue;\r\n\r\n            var parts = bodies[i].parts;\r\n            for (j = parts.length > 1 ? 1 : 0; j < parts.length; j++) {\r\n                var part = parts[j];\r\n                c.font = \"12px Arial\";\r\n                c.fillStyle = 'rgba(255,255,255,0.5)';\r\n                c.fillText(part.id, part.position.x + 10, part.position.y - 10);\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Description\r\n     * @private\r\n     * @method collisions\r\n     * @param {render} render\r\n     * @param {pair[]} pairs\r\n     * @param {RenderingContext} context\r\n     */\r\n    render.collisions = function (pairs) {\r\n        let c = context,\r\n            options = render.options,\r\n            pair,\r\n            collision,            \r\n            i,\r\n            j;\r\n\r\n        c.beginPath();\r\n\r\n        // render collision positions\r\n        for (i = 0; i < pairs.length; i++) {\r\n            pair = pairs[i];\r\n\r\n            if (!pair.isActive)\r\n                continue;\r\n\r\n            collision = pair.collision;\r\n            for (j = 0; j < pair.activeContacts.length; j++) {\r\n                var contact = pair.activeContacts[j],\r\n                    vertex = contact.vertex;\r\n                c.rect(vertex.x - 1.5, vertex.y - 1.5, 3.5, 3.5);\r\n            }\r\n        }\r\n\r\n        if (options.wireframes) {\r\n            c.fillStyle = 'rgba(255,255,255,0.7)';\r\n        } else {\r\n            c.fillStyle = 'orange';\r\n        }\r\n        c.fill();\r\n\r\n        c.beginPath();\r\n\r\n        // render collision normals\r\n        for (i = 0; i < pairs.length; i++) {\r\n            pair = pairs[i];\r\n\r\n            if (!pair.isActive)\r\n                continue;\r\n\r\n            collision = pair.collision;\r\n\r\n            if (pair.activeContacts.length > 0) {\r\n                var normalPosX = pair.activeContacts[0].vertex.x,\r\n                    normalPosY = pair.activeContacts[0].vertex.y;\r\n\r\n                if (pair.activeContacts.length === 2) {\r\n                    normalPosX = (pair.activeContacts[0].vertex.x + pair.activeContacts[1].vertex.x) / 2;\r\n                    normalPosY = (pair.activeContacts[0].vertex.y + pair.activeContacts[1].vertex.y) / 2;\r\n                }\r\n\r\n                if (collision.bodyB === collision.supports[0].body || collision.bodyA.isStatic === true) {\r\n                    c.moveTo(normalPosX - collision.normal.x * 8, normalPosY - collision.normal.y * 8);\r\n                } else {\r\n                    c.moveTo(normalPosX + collision.normal.x * 8, normalPosY + collision.normal.y * 8);\r\n                }\r\n\r\n                c.lineTo(normalPosX, normalPosY);\r\n            }\r\n        }\r\n\r\n        if (options.wireframes) {\r\n            c.strokeStyle = 'rgba(255,165,0,0.7)';\r\n        } else {\r\n            c.strokeStyle = 'orange';\r\n        }\r\n\r\n        c.lineWidth = 1;\r\n        c.stroke();\r\n    };\r\n\r\n    /**\r\n     * Description\r\n     * @private\r\n     * @method separations\r\n     * @param {render} render\r\n     * @param {pair[]} pairs\r\n     * @param {RenderingContext} context\r\n     */\r\n    render.separations = function (pairs) {\r\n        var c = context,\r\n            options = render.options,\r\n            pair,\r\n            collision,\r\n            bodyA,\r\n            bodyB,\r\n            i;\r\n\r\n        c.beginPath();\r\n\r\n        // render separations\r\n        for (i = 0; i < pairs.length; i++) {\r\n            pair = pairs[i];\r\n\r\n            if (!pair.isActive)\r\n                continue;\r\n\r\n            collision = pair.collision;\r\n            bodyA = collision.bodyA;\r\n            bodyB = collision.bodyB;\r\n\r\n            var k = 1;\r\n\r\n            if (!bodyB.isStatic && !bodyA.isStatic) k = 0.5;\r\n            if (bodyB.isStatic) k = 0;\r\n\r\n            c.moveTo(bodyB.position.x, bodyB.position.y);\r\n            c.lineTo(bodyB.position.x - collision.penetration.x * k, bodyB.position.y - collision.penetration.y * k);\r\n\r\n            k = 1;\r\n\r\n            if (!bodyB.isStatic && !bodyA.isStatic) k = 0.5;\r\n            if (bodyA.isStatic) k = 0;\r\n\r\n            c.moveTo(bodyA.position.x, bodyA.position.y);\r\n            c.lineTo(bodyA.position.x + collision.penetration.x * k, bodyA.position.y + collision.penetration.y * k);\r\n        }\r\n\r\n        if (options.wireframes) {\r\n            c.strokeStyle = 'rgba(255,165,0,0.5)';\r\n        } else {\r\n            c.strokeStyle = 'orange';\r\n        }\r\n        c.stroke();\r\n    };\r\n\r\n    return render;\r\n}\r\n\r\n\r\n\r\n\r\nfunction _getTexture(render, imagePath) {\r\n    var image = render.textures[imagePath];\r\n\r\n    if (image)\r\n        return image;\r\n\r\n    image = render.textures[imagePath] = new Image();\r\n    image.src = imagePath;\r\n\r\n    return image;\r\n};","E:\\me\\pifun\\src\\components\\thisworld\\socket.js",[],{"ruleId":"77","replacedBy":"78"},{"ruleId":"79","replacedBy":"80"},{"ruleId":"81","severity":1,"message":"82","line":9,"column":7,"nodeType":"83","messageId":"84","endLine":9,"endColumn":21},{"ruleId":"81","severity":1,"message":"85","line":10,"column":7,"nodeType":"83","messageId":"84","endLine":10,"endColumn":22},{"ruleId":"86","severity":1,"message":"87","line":39,"column":1,"nodeType":"88","endLine":58,"endColumn":3},{"ruleId":"81","severity":1,"message":"89","line":3,"column":24,"nodeType":"83","messageId":"84","endLine":3,"endColumn":30},{"ruleId":"81","severity":1,"message":"90","line":74,"column":9,"nodeType":"83","messageId":"84","endLine":74,"endColumn":30},"no-native-reassign",["91"],"no-negated-in-lhs",["92"],"no-unused-vars","'MAX_WALL_WIDTH' is assigned a value but never used.","Identifier","unusedVar","'MAX_WALL_HEIGHT' is assigned a value but never used.","import/no-anonymous-default-export","Assign object to a variable before exporting as module default","ExportDefaultDeclaration","'points' is assigned a value but never used.","'_cancelAnimationFrame' is assigned a value but never used.","no-global-assign","no-unsafe-negation"]